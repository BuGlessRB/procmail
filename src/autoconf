#! /bin/sh
:
#$Id: autoconf,v 1.56 1993/06/23 14:35:13 berg Exp $

# All possible entries in autoconf.h:

#	#define UNISTD_H_MISSING
#	#define STDDEF_H_MISSING
#	#define STDLIB_H_MISSING
#	#define DIRENT_H_MISSING
#	#define SYS_DIRENT_H_MISSING
#	#define NDIR_H_MISSING
#	#define SYS_NDIR_H_MISSING
#	#define SYS_DIR_H_MISSING
#	#define SYS_WAIT_H_MISSING
#	#define SYS_UTSNAME_H_MISSING
#	#define STRING_H_MISSING
#	#define SYSEXITS_H_MISSING
#Ok	#define SYS_FILE_H_MISSING
#	#define const
#	#define volatile
#	#define P(args) ()
#	#define void char
#	typedef int mode_t;
#	typedef int pid_t;
#	typedef int uid_t;
#	typedef int gid_t;
#	typedef unsigned size_t;
#	typedef long off_t;
#	typedef long time_t;
#	#define NOmemmove
#	#define NObcopy
#	#define NOstrcspn
#	#define NOstrpbrk
#	#define NOopendir
#	#define NOrename
#	#define NOsetrgid
#	#define NOsetregid
#	#define NOmkdir
#	#define NOuname
#	#define NOstrstr
#	#define NOstrtol
#	#define strchr(s,c) index(s,c)
#	#define initgroups(n,g)
#Ok	#define endpwent()
#Ok	#define endgrent()
#Ok	#define endhostent()
#Ok	#define endservent()
#Ok	#define endprotoent()
#	#define h_0addr_list h_addr
#Ok	#define NO_COMSAT
#	#define _GUID_T
#Ok	#define UDP_protocolno 17
#Ok	#define BIFF_serviceport "512"
#Ok	#define IP_localhost {127,0,0,1,}
#	#define WMACROS_NON_POSIX
#	#define oBRAIN_DAMAGE
#Ok	#define LD_ENV_FIX
#Ok	#define GOT_bin_test
#Ok	#define SMALLHEAP
#	#define NOfcntl_lock
#Ok	#define USElockf
#Ok	#define USEflock
#Ok	#define SYSTEM_MAILBOX "/usr/spool/mail/$LOGNAME"
#Ok	#define SENDMAIL "/usr/lib/sendmail"
#Ok	#define CF_no_procmail_yet

# A conforming ANSI compiler and POSIX library should not have any defines not
# marked as "Ok" in the autoconf.h file.
# Anything else indicates failure of your system to comply with either
# the ANSI or POSIX standards (but procmail should be installable anyway).

SHELL=$1
PATH=.:$PATH
shift; RM="$1"
shift; MV="$1"
shift; DEVNULL=$1
shift; FGREP="$1"
shift; MAKE="$1"
shift; O=$1
shift; LOCKINGTEST="$1"
shift; ACONF=$1

test 1 != $# &&
 echo "Don't start this script directly, use \`make ../autoconf.h'" && exit 1

export SHELL PATH

OLDTESTDIRS=""
tailpid=""
echo "" >_locktst.pid

if test -f $ACONF
then
  trap "kill \`cat _locktst.pid\` 2>$DEVNULL;cp $ACONF $ACONF.tmp
   $RM -r \$OLDTESTDIRS;test ! -z \"\$tailpid\" && kill \$tailpid 2>$DEVNULL
   kill \`cat _locktst.pid\` 2>$DEVNULL; exit 1" 1 2 3 15
else
  trap "kill \`cat _locktst.pid\` 2>$DEVNULL;$RM -r \$OLDTESTDIRS $ACONF.tmp
   mv $ACONF $ACONF.tmp 2>$DEVNULL
   test ! -z \"\$tailpid\" && kill \$tailpid 2>$DEVNULL
   kill \`cat _locktst.pid\` 2>$DEVNULL; exit 1" 1 2 3 15
fi

nocore=yes
test -f core && nocore=no

cat 2>&1 <<HERE
==============================================================================
In order for the kernel-locking tests to work as intended I have to be able to
test-lock files on as many semantically different filesystems as possible (for
more information about this, READ PARAGRAPH TWO in INSTALL).  To suppress this
prompt you can set the LOCKINGTEST variable in the Makefile.

Please add writeable directories to the list.  You should only add directories
that reside on filesystems that have unique characterics.  E.g. if you have
several remote NFS partitions, pick some unique client-server pairs, there is
little use in picking the same server twice from the same client-machine.
An excellent candidate would be a remotely mounted mail spool directory.
==============================================================================
HERE

testdirs="/tmp ."
b=dummy
while test ! -z "$b"
do
  echo 2>&1 ""
  b=""
  OLDTESTDIRS="$TESTDIRS"
  TESTDIRS=""
  for a in $testdirs
  do $RM -r $a/_locktest
     if mkdir $a/_locktest
     then
	b="$b $a"
	TESTDIRS="$TESTDIRS $a/_locktest"
     else
	echo 2>&1 "Can't create $a/_locktest"
     fi
  done
  OLDTESTDIRS="$TESTDIRS"
  testdirs="$b"
  echo 2>&1 ""
  echo 2>&1 "I will temporarily use a testdirectory named _locktest"
  echo 2>&1 "in the following directories:"
  echo 2>&1 ""
  echo 2>&1 $testdirs
  echo 2>&1 ""
  echo 2>&1 "If you would like to add any, please specify them below,"
  echo 2>&1 "press return to continue:"
  echo 2>&1 ""
  if test -z "$LOCKINGTEST"
  then
     read b
  elif test dummy = "$LOCKINGTEST"
  then
     b=""
  else
     testdirs=""; b="$LOCKINGTEST"; LOCKINGTEST=dummy
     echo $b
  fi
  testdirs="$testdirs $b"
done

cat >grepfor <<HERE
$FGREP -e "\$1" _autotst.rrr >$DEVNULL && echo "\$2" >>$ACONF
HERE
chmod 0755 grepfor

cat >$ACONF <<HERE
/* This file was automagically generated by autoconf */

HERE

echo >_locktst.h

$RM _autotst.$O

cat >_autotst.c <<HERE
#include "$ACONF"
#include <sys/types.h>
#include <time.h>
void*vvoid;
main(){int i;char*p="t";
 {time_t vtime_t;i=vtime_t=1;}
 {off_t voff_t;i=voff_t=1;}
 vvoid=p;
 return !vvoid;}
#include <unistd.h>
struct {char a;char b;} setsid;
HERE

if $MAKE _autotst.$O 2>&1 | $FGREP -v include/ >_autotst.rrr
 test -f _autotst.$O
then
  echo "#define setsid()" >>_locktst.h
else
  grepfor void '#define void char'
  grepfor time_t 'typedef long time_t;'
  grepfor off_t 'typedef long off_t;'
  if $FGREP setsid _autotst.rrr >$DEVNULL 2>&1
  then
  :
  else
     echo "#define setsid()" >>_locktst.h
     $MAKE _autotst.$O 2>&1 >$DEVNULL
     test -f _autotst.$O || echo "#define UNISTD_H_MISSING" >>$ACONF
  fi
fi

$RM _autotst.$O _autotst

cat >_autotst.c <<HERE
#include "$ACONF"
#include <sys/types.h>
#ifndef UNISTD_H_MISSING
#include <unistd.h>
#endif
#include <fcntl.h>
#ifndef SYS_FILE_H_MISSING
#include <sys/file.h>
#endif
main(){
#ifdef F_SETLKW
 fcntl(0,F_SETLKW,0);
#endif
#ifdef F_LOCK
  lockf(0,F_LOCK,(off_t)0);
#endif
#ifdef LOCK_EX
  flock(0,LOCK_EX);
#endif
 return 0;}
HERE

echo 'Initiating fcntl()/kernel-locking-support tests'
if $MAKE _autotst.$O >$DEVNULL 2>&1
then
:
else
  $RM _autotst.$O
  echo "#define SYS_FILE_H_MISSING" >>$ACONF
  if $MAKE _autotst.$O >_autotst.rrr 2>&1
  then
  :
  else
     echo 2>&1 "Whoeaaa!  There's something fishy going on here."
     echo 2>&1 "You have a look and see if you detect anything uncanny:"
     echo 2>&1 "*******************************************************"
     cat 2>&1 _autotst.rrr
     echo 2>&1 "*******************************************************"
     echo 2>&1 "I suggest you take a look at the definition of CFLAGS* and CC"
     echo 2>&1 "in the Makefile before you try make again."
     kill -15 $$
  fi
fi
$MAKE _autotst >_autotst.rrr 2>&1
$RM _autotst.$O _autotst

$FGREP fcntl _autotst.rrr >$DEVNULL && echo "#undef F_SETLKW" >>_locktst.h
$FGREP lockf _autotst.rrr >$DEVNULL && echo "#undef F_LOCK" >>_locktst.h
$FGREP flock _autotst.rrr >$DEVNULL && cat >>_locktst.h <<HERE
#ifdef LOCK_EX
#undef LOCK_EX
#endif
#ifndef SYS_FILE_H_MISSING
#define SYS_FILE_H_MISSING
#endif
HERE

cat >_autotst.c <<HERE
#include "$ACONF"
#include "../config.h"
#include <sys/types.h>
#ifndef UNISTD_H_MISSING
#include <unistd.h>		/* getpid() getppid() */
#endif
#include <stdio.h>
#include <time.h>
#include <fcntl.h>
#include <signal.h>		/* SIGKILL */
#ifndef tell
#define tell(fd)	lseek(fd,(off_t)0,SEEK_CUR)
#endif
#define EX_OK	0
#include "_locktst.h"
#ifndef SYS_FILE_H_MISSING
#include <sys/file.h>
#endif
#ifndef SEEK_SET
#define SEEK_SET	0
#define SEEK_CUR	1
#define SEEK_END	2
#endif

#define MIN_locks	128	  /* minimum of consecutive successful locks */
#define SLEEP_loop	64		      /* iterations in the busy loop */
#define SLEEP_delay	0		  /* sleep() time per busy iteration */
#define SLEEP_retreat	1		 /* extra sleep() when quota reached */
#define TIME_OUT_SEC	16			 /* initial timeout per lock */
#define NR_of_forks	8			 /* concurrent test-programs */
#define NR_of_lockfiles 2		  /* lockfiles used in testing (<=4) */
#define GROW		3			    /* when timing got worse */
#define DECAY		7/8			   /* when timing got better */
#define GOBBLE		256			 /* for the SunOS crash test */

#define LOCKS_per_child (((MIN_locks+NR_of_forks-1)/NR_of_forks+1)/2)
#define SHIFT_childno	3
#define MASK_fileno	((1<<SHIFT_childno)-1)
#define MASK_childno	(~MASK_fileno)

#ifdef NO_fcntl_LOCK
#undef F_SETLKW
#endif
#ifdef NO_lockf_LOCK
#undef F_LOCK
#endif
#ifdef NO_flock_LOCK
#undef LOCK_EX
#endif

#define FIRST_lock	0x04		/* testing is in order of importance */
#define MSK_fcntl	0x04	       /* don't change this order unless you */
#define MSK_lockf	0x02	       /* change locking.c as well, fdlock() */
#define MSK_flock	0x01

int dolock,child[NR_of_forks],timeout,fdcollect;
char dirlocktest[]="_locktest";

void stimeout()
{ timeout=1;close(fdcollect);killchildren();
}

void terminate()
{ stimeout();exit(1);
}

static unsigned long seed;

unsigned psrand()
{ return(unsigned)(seed*=69069L)>>8;
}

unsigned sfork()
{ int pid;
  while((pid=fork())<0)
     fprintf(stderr,"Couldn't fork _locktst, retrying\n"),sleep(TIME_OUT_SEC);
  return pid;
}

main(argc,argv)char*argv[];
{ int goodlock,testlock,i,pip[2],pipw[2];unsigned otimet,dtimet;
  static char filename[]="_locktst.l0";
  close(0);goodlock=0;testlock=FIRST_lock;signal(SIGPIPE,SIG_DFL);
  if(sfork())				 /* try to ditch the controlling tty */
     return EX_OK;	/* mainly to prevent rather messy kernel-diagnostics */
  setsid();				       /* from appearing on your tty */
  do
   { int countlocks;
     signal(SIGTERM,SIG_DFL);argc=1;dolock=goodlock|testlock;
     do
      { char*curdir;
	curdir=argv[argc];otimet=time((time_t*)0);
	if(sfork())
	 { close(1);close(2);i=NR_of_lockfiles;chdir(curdir);
	   chdir(dirlocktest);
	   do			       /* prime the lock, see if it vanishes */
	    { filename[sizeof filename-2]='0'+--i;
	      lseek(goodlock=open(filename,O_WRONLY),(off_t)0,SEEK_END);
	      fdlock(goodlock);
	    }
	   while(i);
	   for(;;)				/* synchronising "busy"-wait */
	      sleep(TIME_OUT_SEC);	   /* until the games can be started */
	 }
	sleep(1);pipe(pip);pipe(pipw);i=NR_of_forks;*child=0;
	fprintf(stderr,"\nStarting test %x on %s\n",dolock,curdir);
	while((child[--i]=sfork())&&i);		       /* divide and conquer */
	if(!*child)
	 { unsigned char lockflag;int fd,childno=i<<SHIFT_childno;
	   int mylocks=LOCKS_per_child;
	   close(pipw[0]);close(pip[0]);close(1);
	   seed=time((time_t*)0)+getpid()|1;chdir(curdir);chdir(dirlocktest);
	   close(pipw[1]);
	   for(;;)					   /* and lock away! */
	    { filename[sizeof filename-2]='0'+(i=psrand()%NR_of_lockfiles);
	      lockflag=childno|i<<1|1;
	      lseek(fd=open(filename,O_WRONLY),(off_t)0,SEEK_END);
	      if(sfdlock(fd))
		 lockflag&=~1,fprintf(stderr,"XX%02x",lockflag);
	      write(pip[1],&lockflag,1);
	      fprintf(stderr,"%2x%02x",i,childno>>SHIFT_childno);
	      lseek(fd,(off_t)0,SEEK_END);write(fd,&lockflag,1);
	      for(i=SLEEP_loop;i;i--,time((time_t*)0),sleep(SLEEP_delay));
	      lockflag&=~1;write(pip[1],&lockflag,1);
	      if(fdunlock()||close(fd))
	       { write(pip[1],&lockflag,1);fprintf(stderr,"XX%02x",lockflag);
		 return 1;
	       }
	      if(--mylocks<0)
		 sleep(SLEEP_retreat);
	    }
	 }
	signal(SIGTERM,terminate);
	;{ unsigned char lckdfil[NR_of_lockfiles],curflag;
	   int j,ppid;			       /* give all children a chance */
	   ppid=getppid();
	   if(sfork())	/* discard the old body, let init adopt our children */
	      return EX_OK;
	   ;{ FILE*fp;
	      if(fp=fopen("_locktst.pid","w"))
		 fprintf(fp,"%ld",(long)getpid()),fclose(fp);
	    }
	   countlocks=MIN_locks;close(pip[1]);close(pipw[1]);
	   for(j=NR_of_lockfiles;lckdfil[--j]=0,j;);
	   timeout=0;sleep(1);read(pipw[0],&curflag,1);close(pipw[0]);
	   kill(ppid,SIGKILL);fdcollect=pip[0];signal(SIGALRM,stimeout);
	   dtimet=(((unsigned)time((time_t*)0)-otimet)*GROW)+TIME_OUT_SEC;
	   do
	    { unlink("_locktst.alive");alarm(dtimet+2);		 /* watchdog */
	      dtimet=(otimet=time((time_t*)0)-otimet)>dtimet?
	       otimet*GROW:otimet+(dtimet-otimet)*DECAY+1; /* load dependent */
	      otimet=time((time_t*)0);
	    }
	   while(1==read(fdcollect,&curflag,1)&&
	    (j=lckdfil[i=(curflag&MASK_fileno)>>1],!timeout)&&
	    ((j^(lckdfil[i]=curflag))==1||!(j&1)&&curflag&1)&&--countlocks);
	   alarm(0);close(fdcollect);killchildren();
	   fprintf(stdout,
	    "/*locktype: %x, countlocks: %x, timeout %x, watchdog %x, %s*/\n",
	    dolock,countlocks,timeout,dtimet,curdir);fflush(stdout);
	 }
      }
     while(!countlocks&&argv[++argc]);
     if(!countlocks)			    /* Hurray!	Locking was flawless */
	goodlock=dolock;			  /* make a mark on our colt */
   }
  while(testlock>>=1);
  if(!(goodlock&MSK_fcntl))			      /* report our findings */
     puts("#define NOfcntl_lock");
  if(goodlock&MSK_lockf)
     puts("#define USElockf");
  if(goodlock&MSK_flock)
   { puts("#define USEflock");
#ifdef SYS_FILE_H_MISSING
     puts("#define SYS_FILE_H_MISSING");
#endif
   }
  puts("Kernel-locking tests completed.");
  return EX_OK;
}

killchildren()
{ int i;
  i=NR_of_forks;
  do
     if(child[--i]>0)
	kill(child[i],SIGTERM),child[i]=0;
  while(i);
}

sfdlock(fd)
{ int i;unsigned gobble[GOBBLE>>2];
  for(i=GOBBLE>>2;i;gobble[--i]=~(unsigned)0);		 /* SunOS crash test */
  return fdlock(fd);
}

static oldfdlock;
#ifdef F_SETLKW
static struct flock flck;		/* why can't it be a local variable? */
#endif
#ifdef F_LOCK
static off_t oldlockoffset;
#endif

fdlock(fd)
{ int i;unsigned gobble[GOBBLE>>2];
  for(i=GOBBLE>>2;i;gobble[--i]=~(unsigned)0);		 /* SunOS crash test */
  oldfdlock=fd;fd=0;
  if(MSK_fcntl&dolock)
#ifdef F_SETLKW
   { flck.l_type=F_WRLCK;flck.l_whence=SEEK_SET;flck.l_len=0;
     flck.l_start=tell(oldfdlock);fd|=fcntl(oldfdlock,F_SETLKW,&flck);
   }
#else
     fd=1;
#endif
  if(MSK_lockf&dolock)
#ifdef F_LOCK
     oldlockoffset=tell(oldfdlock),fd|=lockf(oldfdlock,F_LOCK,(off_t)0);
#else
     fd=1;
#endif
  if(MSK_flock&dolock)
#ifdef LOCK_EX
     fd|=flock(oldfdlock,LOCK_EX);
#else
     fd=1;
#endif
  return fd;
}

fdunlock()
{ int i;unsigned gobble[GOBBLE];
  for(i=GOBBLE;i;gobble[--i]=~(unsigned)0);		 /* SunOS crash test */
  if(MSK_flock&dolock)
#ifdef LOCK_EX
     i|=flock(oldfdlock,LOCK_UN);
#else
     i=1;
#endif
  if(MSK_lockf&dolock)
#ifdef F_LOCK
   { lseek(oldfdlock,oldlockoffset,SEEK_SET);
     i|=lockf(oldfdlock,F_LOCK,(off_t)2);i|=lockf(oldfdlock,F_ULOCK,(off_t)0);
   }
#else
     i=1;
#endif
  if(MSK_fcntl&dolock)
#ifdef F_SETLKW
   { flck.l_len=2;i|=fcntl(oldfdlock,F_SETLK,&flck);flck.l_type=F_UNLCK;
     flck.l_len=0;i|=fcntl(oldfdlock,F_SETLK,&flck);
   }
#else
     i=1;
#endif
  if(!i)
     for(i=GOBBLE;i&&gobble[--i]==~(unsigned)0;);
  return i;
}
HERE

if $MAKE _autotst >_autotst.rrr 2>&1
then
:
else
  echo 2>&1 "Whoeaaa!  There's something fishy going on here."
  echo 2>&1 "You have a look and see if you detect anything uncanny:"
  echo 2>&1 "*******************************************************"
  cat 2>&1 _autotst.rrr
  echo 2>&1 "*******************************************************"
  echo 2>&1 "I suggest you take a look at the definition of LDFLAGS*"
  echo 2>&1 "in the Makefile before you try make again."
  kill -15 $$
fi

$MV _locktst _locktst.$$ 2>$DEVNULL
$RM _autotst.$O _autotst.rrr locktst* 2>$DEVNULL
$MV _autotst _locktst

for b in $TESTDIRS
do
  for a in 0 1 2 3
  do echo dummy_file >$b/_locktst.l$a
  done
done

echo 2>&1 ""

_locktst $TESTDIRS >_locktst.rrr 2>lock.log	# will finish in the background
echo 'Proceeding with kernel-locking-support tests in the background'

cat >_autotst.c <<HERE
#include "$ACONF"
#ifndef UNISTD_H_MISSING
#include <unistd.h>		/* execvp() */
#endif
main()
{ char r[]="",*const*p;char*q="";const char*s="";
  static struct{const int a;int b;}c[2];
  --(c+1)->b;				 /* AIX 3.1.5 machines can't do this */
  p= &q;
  execvp(q,p);	  /* IRIX 4.0.1 system-include files are wrong on this point */
  return r==s;		    /* Domain/OS warns here, not about "s==r" though */
}
HERE

echo 'Testing for const'
if $MAKE _autotst.$O 2>&1 | $FGREP -v include/ >_autotst.rrr
 test -f _autotst.$O
then
  grepfor const '#define const'
else
  echo '#define const' >>$ACONF
fi
$RM _autotst.$O

cat >_autotst.c <<HERE
main(){volatile int i;return(i=0);}
HERE

echo 'Testing for volatile'
if $MAKE _autotst.$O >$DEVNULL 2>&1 && test -f _autotst.$O
then
:
else
 echo '#define volatile' >>$ACONF
fi
$RM _autotst.$O

if $FGREP const $ACONF >$DEVNULL
then
  echo '#define P(args) ()' >>$ACONF
else
  cat >_autotst.c <<HERE
main(const argc,const char*const argv[]){return argc;}
HERE

  echo 'Testing for prototypes'
  if $MAKE _autotst.$O >$DEVNULL 2>&1 && test -f _autotst.$O
  then
  :
  else
     echo '#define P(args) ()' >>$ACONF
  fi
  $RM _autotst.$O
fi

echo 'Checking for POSIX and ANSI system include files'

cat >_autotst.c <<HERE
#include "includes.h"
int a;
HERE

i0="";i1="";i2="";i3="";i4="";i5="";i6="";i7="";i8="";i9="";i10="";
oldi=""

while $MAKE _autotst.$O 2>&1 | $FGREP -v include/ >_autotst.rrr
 test ! -f _autotst.$O
do
  test -z "$i0" && grepfor stddef.h "#define STDDEF_H_MISSING" && i0=I
  test -z "$i1" && grepfor stdlib.h "#define STDLIB_H_MISSING" && i1=I
  test -z "$i2" && grepfor dirent.h "#define DIRENT_H_MISSING" && i2=I
  test -z "$i3" && grepfor ndir.h "#define NDIR_H_MISSING" && i3=I
   test I = "$i3$i4" && grepfor sys/ndir.h "#define SYS_NDIR_H_MISSING" && i4=I
    test I = "$i4$i5" && grepfor sys/dir.h "#define SYS_DIR_H_MISSING" && i5=I
     test I = "$i5$i6" && grepfor sys/dirent.h "#define SYS_DIRENT_H_MISSING" \
      && i6=I
  test -z "$i7" && grepfor sys/wait.h "#define SYS_WAIT_H_MISSING" && i7=I
  test -z "$i8" && grepfor sys/utsname.h "#define SYS_UTSNAME_H_MISSING" &&
   i8=I
  test -z "$i9" && grepfor string.h "#define STRING_H_MISSING" && i9=I
  test -z "$i10" && grepfor sysexits.h "#define SYSEXITS_H_MISSING" && i10=I
  newi="$i0$i1$i2$i3$i4$i5$i6$i7$i8$i9$i10"
  if test a$oldi = a$newi
  then
     echo 2>&1 "Whoeaaa!  There's something fishy going on here."
     echo 2>&1 "You have a look and see if you detect anything uncanny:"
     echo 2>&1 "*******************************************************"
     $MAKE _autotst.$O >_autotst.rrr 2>&1
     cat 2>&1 _autotst.rrr
     echo 2>&1 "*******************************************************"
     echo 2>&1 "I suggest you take a look at the definition of CFLAGS*"
     echo 2>&1 "in the Makefile before you try make again."
     kill -15 $$
  fi
  oldi=$newi
  echo \
   "	...missing `expr $oldi : '.*'` include files, doublechecking..."
done

$RM _autotst.$O

cat >_autotst.c <<HERE
#include "includes.h"
#include "network.h"
int a;
HERE

echo 'Checking for network/comsat/biff support'

if $MAKE _autotst.$O 2>&1 | $FGREP -v include/ >_autotst.rrr
 test -f _autotst.$O
then
:
else
  echo "#define NO_COMSAT" >>$ACONF
fi

$RM _autotst.$O

cat >_autotst.c <<HERE
#include "includes.h"
#ifndef NO_COMSAT
#include "network.h"
#endif
main(){int i;
 {size_t vsize_t;i=vsize_t=1;}
 {pid_t vpid_t;i=vpid_t=1;}
 {mode_t vmode_t;i=vmode_t=1;}
 {uid_t vuid_t;i=vuid_t=1;}
 {gid_t vgid_t;i=vgid_t=1;}
#ifndef NO_COMSAT
 {struct hostent host;i=!(host.h_addr_list=0);}
#endif
 return !i;}
HERE

echo 'Testing for void*,size_t,off_t,pid_t,time_t,mode_t,uid_t,gid_t'
$MAKE _autotst.$O 2>&1 | $FGREP -v include/ >_autotst.rrr
$RM _autotst.$O

grepfor size_t 'typedef unsigned size_t;'
grepfor pid_t 'typedef int pid_t;'
grepfor mode_t 'typedef int mode_t;'
grepfor uid_t 'typedef int uid_t;'
grepfor gid_t 'typedef int gid_t;'
grepfor h_addr_list '#define h_0addr_list h_addr' ||
 grepfor struct '#define h_0addr_list h_addr'

cat >_autotst.c <<HERE
#include "includes.h"
main(){int i;i=1;
 i+=WIFEXITED(i);
 i+=WIFSTOPPED(i);
 i+=WEXITSTATUS(i);
 return i;}
HERE

echo 'Testing for WIFEXITED(), WIFSTOPPED() & WEXITSTATUS()'
if $MAKE _autotst.$O 2>&1 | $FGREP -v include/ >_autotst.rrr
then
   grepfor struct '#define WMACROS_NON_POSIX' ||
    grepfor union '#define WMACROS_NON_POSIX'
else
   echo '#define WMACROS_NON_POSIX' >>$ACONF
fi
$RM _autotst.$O

cat >_autotst.c <<HERE
#include "includes.h"
#ifndef NO_COMSAT
#include "network.h"
#endif
main(){char a[2];
 endpwent();endgrent();memmove(a,"0",1);bcopy("0",a,1);strcspn(a,"0");
 strtol("0",(char**)0,10);strchr("0",'0');strpbrk(a,"0");rename(a,"0");
 setrgid(0);setregid(0,0);opendir("0");initgroups("0",0);strstr("0","0");
 mkdir("0",0);
#ifndef NOuname
 {struct utsname b;uname(&b);}
#endif
#ifndef NO_COMSAT
 gethostbyname("0");getprotobyname(COMSATprotocol);endhostent();endservent();
 endprotoent();
#endif
 return 0;}
HERE

echo 'Testing for memmove, strchr, strpbrk, strcspn, strtol, strstr,'
echo '	rename, setrgid, opendir & mkdir'
if $MAKE _autotst.$O >_autotst.rrr 2>&1
then
:
else
  echo 2>&1 "Whoeaaa!  There's something fishy going on here."
  echo 2>&1 "You have a look and see if you detect anything uncanny:"
  echo 2>&1 "*******************************************************"
  cat 2>&1 _autotst.rrr
  echo 2>&1 "*******************************************************"
  echo 2>&1 "Your include files seem to be beyond repair <sigh>."
  echo 2>&1 "I give up."
  kill -15 $$
fi
$MAKE _autotst 2>&1 | $FGREP -v include/ >_autotst.rrr
$RM _autotst _autotst.$O

grepfor strcspn '#define NOstrcspn'
grepfor strpbrk '#define NOstrpbrk'
grepfor opendir "
#define NOopendir	/* the readdir library does not seem to be available
			   this will slightly affect the way a filenumber is
			   selected in MH-folders by procmail */
"
grepfor rename '#define NOrename'
grepfor setrgid '#define NOsetrgid' &&
 grepfor setregid '#define NOsetregid'
grepfor mkdir '#define NOmkdir'
grepfor strchr '#define strchr(s,c) index(s,c)'
grepfor uname "\
#define NOuname		 \
/* the include files define it, the libraries don't */"
grepfor initgroups '#define initgroups(n,g)'
grepfor endpwent '#define endpwent()'
grepfor endgrent '#define endgrent()'
if grepfor gethostbyname '#define NO_COMSAT'
then
:
else
  grepfor getprotobyname '#define UDP_protocolno 17'
  grepfor endhostent '#define endhostent()'
  grepfor endservent '#define endservent()'
  grepfor endprotoent '#define endprotoent()'
fi
grepfor strtol '#define NOstrtol'
grepfor strstr '#define NOstrstr'
grepfor memmove '#define NOmemmove' &&
if $FGREP -e bcopy _autotst.rrr >$DEVNULL
then
 echo '#define NObcopy' >>$ACONF

 echo 'Testing for brain damage'
 cat >_autotst.c <<HERE
#include "includes.h"
struct tests{int a,b;};
main(){
 return offsetof(struct tests,b);}
HERE
 if $MAKE _autotst.$O >$DEVNULL 2>&1
 then
    :
 else
    echo 'Yep, it is'			# ISC chokes on its own offsetof()
    echo '#define oBRAIN_DAMAGE' >>$ACONF
 fi
 $RM _autotst.$O

else

 cat >_autotst.c <<HERE
#include "includes.h"
#define M256	256
#define F33	33
main(){int j=0,i=M256-1;static char a[M256];
  do a[i]=i;while(i--);
  bcopy(a+F33,a,M256-F33);bcopy(a,a+F33,M256-F33);i=F33-1;
  do j|=a[i]!=(char)(i+F33);while(i--);i=M256-1;
  do j|=a[i]!=(char)i;while(--i!=F33-1);return!j;}
HERE

 echo 'Testing for bcopy handling overlaps'
 $MAKE _autotst >$DEVNULL 2>&1

 if _autotst
 then
   echo 'Sorry, incompetent bcopy'
   echo '#define NObcopy' >>$ACONF
 fi
 $RM _autotst
fi

$FGREP -e LD_ /bin/ld >/dev/null 2>&1 && echo "#define LD_ENV_FIX" >>$ACONF
test -f /bin/test && echo "#define GOT_bin_test" >>$ACONF

cat >_autotst.c <<HERE
#include "includes.h"
#ifndef NO_COMSAT
#include "network.h"					 /* also for ntohs() */
#endif
main(argc)
{ unsigned long s=(size_t)~0;int i;
  for(i=1;s>>=1;i++);
  if(argc==1)
   {
#ifndef NO_COMSAT
#ifndef UDP_protocolno
     ;{ const struct protoent*p;
	if(p=getprotobyname(COMSATprotocol))
	 { printf("#define UDP_protocolno %d\n",p->p_proto);
#else
     ;{ if(1)
	 {
#endif
	   ;{ const struct servent*serv;
	      if(serv=getservbyname(COMSATservice,COMSATprotocol))
		 printf("#define BIFF_serviceport \"%d\"\n",
		  ntohs(serv->s_port));
	    }
#ifdef AF_INET
	   ;{ const struct hostent*host;
	      if(!strcmp("localhost",COMSAThost)&&
	       (host=gethostbyname(COMSAThost))&&
	       host->h_0addr_list&&host->h_addrtype==AF_INET&&
	       host->h_length)
	       { int j=host->h_length;
		 const unsigned char*ad=(void*)host->h_0addr_list;
		 printf("#define IP_localhost {");
		 do printf("%d,",*ad++);
		 while(--j);
		 puts("}");
	       }
	    }
#endif /* AF_INET */
	 }
	else
	   puts("#define NO_COMSAT");
      }
#endif /* NO_COMSAT */
     if(i<=16)
      { puts("#define SMALLHEAP");return 1;
      }
#ifdef _GUID_T						      /* ISC cc hack */
     ;{ struct passwd*p;
	if(sizeof(int)>sizeof(uid_t)&&(p=getpwnam("root"))&&(*p->pw_dir!='/'||
	 (*p->pw_shell&&!(p->pw_shell)[1])))
	   puts("#define _GUID_T\ntypedef int uid_t;\ntypedef int gid_t;");
      }
#endif
   }
#ifdef SYSTEM_MBOX
  if(argc==2)
   { printf("#define SYSTEM_MAILBOX %s\n",SYSTEM_MBOX);return 1;
   }
#endif
#ifdef DEFsendmail
  if(argc==3)
   { printf("#define SENDMAIL %s\n",DEFsendmail);return 1;
   }
#endif
  return 0;
}
HERE

echo 'Determining the most applicable block size'

$MAKE _autotst >$DEVNULL 2>&1
_autotst >>$ACONF

found=no
for a in /usr/spool/mail /usr/mail /var/spool/mail /var/mail /spool/mail
do
  test -d $a -a $found != yes &&
   echo '#define SYSTEM_MAILBOX "'$a'/$LOGNAME"' >>$ACONF && found=yes
done
if test $found != yes && _autotst 2 >>$ACONF
then
 echo '#define SYSTEM_MAILBOX "$HOME/.mail"' >>$ACONF
 echo Could not find the system-mailbox directory, supplied substitute
fi

cat >lookfor <<HERE
for a in /usr/lib /lib /usr/etc /etc /usr/bin /bin /usr/local/bin /usr/lbin \
 /usr/local/lib /usr/local /usr/.lib /local/bin
do
 if test -f "\$a/\$1"
 then
    echo "#define SENDMAIL \"\$a/\$1\"" >>$ACONF
    exit 0
 fi
done
exit 1
HERE
chmod 0755 lookfor

if lookfor sendmail || lookfor smail || lookfor rmail || lookfor mail
then
:
elif _autotst 2 3 >>$ACONF
then
 echo 'Could not find any mailer.  It should be a mailer accepting at least'
 echo 'one plain destination address as its only argument (any sendmail'
 echo 'compatible mailer will do), and the mail-to-be-sent on stdin.'
 echo 'What is your mailer called?  (You can override this in config.h)'
 read a
 echo "#define SENDMAIL \"$a\"" >>$ACONF
fi

cat /usr/lib/sendmail.cf /etc/sendmail.cf 2>$DEVNULL |
 grep 'Mlocal.*procmail' >$DEVNULL ||
 echo '#define CF_no_procmail_yet' >>$ACONF

while $FGREP -e "Kernel-locking tests completed." _locktst.rrr >$DEVNULL; \
 test 0 != $?
do
  if test -z "$tailpid"
  then
     echo "Waiting for the kernel-locking tests to finish..."
     exec 9>&2 2>$DEVNULL
     tail -f lock.log &
     tailpid=$!
     exec 2>&9 9>&-
  fi
# if test ! -f _locktst.alive
# then
#    echo >_locktst.alive
#    echo "Waiting for kernel-locking tests to finish..."
# fi
  sleep 4
done
exec 9>&2 2>$DEVNULL
test ! -z "$tailpid" && kill $tailpid && echo && echo
tailpid=""
exec 2>&9 9>&-
echo "Collecting results from kernel-locking tests"
sed -e '/^Kernel-locking tests completed./,$ d' <_locktst.rrr >>$ACONF
if test -f core -a $nocore = yes
then
  echo "Removing core file (probably from the locking tests)"
  $RM core
fi

$RM -r $OLDTESTDIRS 2>$DEVNULL
$RM _autotst* _locktst* lookfor grepfor 2>$DEVNULL

echo =============================autoconf.h===================================
cat $ACONF
echo ==========================================================================

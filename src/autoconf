#! /bin/sh
:
#$Id: autoconf,v 1.22 1993/01/13 16:17:12 berg Exp $

# All possible entries in autoconf.h:

#	#define UNISTD_H_MISSING
#	#define STDDEF_H_MISSING
#	#define STDLIB_H_MISSING
#	#define DIRENT_H_MISSING
#	#define SYS_DIRENT_H_MISSING
#	#define NDIR_H_MISSING
#	#define SYS_NDIR_H_MISSING
#	#define SYS_DIR_H_MISSING
#	#define SYS_WAIT_H_MISSING
#	#define SYS_UTSNAME_H_MISSING
#	#define STRING_H_MISSING
#	#define SYSEXITS_H_MISSING
#Ok	#define SYS_FILE_H_MISSING
#	#define const
#	#define volatile
#	#define P(args) ()
#	#define void char
#	typedef int mode_t;
#	typedef int pid_t;
#	typedef int uid_t;
#	typedef int gid_t;
#	typedef unsigned size_t;
#	typedef long time_t;
#	#define NOmemmove
#	#define NObcopy
#	#define NOstrcspn
#	#define NOstrpbrk
#	#define NOopendir
#Ok	#define NOrename
#	#define NOuname
#	#define NOstrtol
#	#define strchr(s,c) index(s,c)
#	#define initgroups(n,g)
#Ok	#define endpwent()
#Ok	#define endgrent()
#Ok	#define endhostent()
#Ok	#define endservent()
#Ok	#define endprotoent()
#	#define h_addr_list h_addr
#Ok	#define NO_COMSAT
#	#define _GUID_T
#Ok	#define UDP_protocolno 17
#Ok	#define BIFF_serviceport "512"
#Ok	#define IP_localhost {127,0,0,1,}
#	#define WMACROS_NON_POSIX
#	#define oBRAIN_DAMAGE
#Ok	#define LD_ENV_FIX
#Ok	#define GOT_bin_test
#Ok	#define SMALLHEAP
#	#define NOfcntl_lock
#	#define USElockf
#	#define USEflock
#Ok	#define SYSTEM_MAILBOX "/usr/spool/mail/$LOGNAME"
#Ok	#define SENDMAIL "/usr/lib/sendmail"
#Ok	#define CF_no_procmail_yet

# A conforming ANSI compiler and POSIX library should only have the defines
# preceded by "Ok" in the autoconf.h file.
# Anything else indicates failure of your system to comply with either
# the ANSI or POSIX standards (but procmail should be installable anyway).

SHELL=$1
PATH=.:$PATH
shift; RM="$1"
shift; MV="$1"
shift; USRINC=$1
shift; DEVNULL=$1
shift; FGREP="$1"
shift; MAKE="$1"
shift; O=$1
shift; ACONF=$1

test 1 != $# &&
 echo "Don't start this script directly, use \`make ../autoconf.h'" && exit 1

export SHELL PATH
if test -f $ACONF
then
 trap "exit 1" 1 2 3 15
else
 trap "$RM $ACONF; exit 1" 1 2 3 15
fi

if test ! -z "$LD_LIBRARY_PATH"
then
  echo '***************************** WARNING *********************************'
  echo '* You seem to have set the LD_LIBRARY_PATH variable, this might cause *'
  echo '* some trouble during the execution of this autoconf script.  If the  *'
  echo '* the make does not finish by itself, do a: "make clean",	      *'
  echo '* clear LD_LIBRARY_PATH from the environment, and start over.	      *'
  echo '***************************** WARNING *********************************'
fi

echo hi | $FGREP hi >$DEVNULL
t=$?
echo ho | $FGREP hi >$DEVNULL
f=$?
if test 0 != $t -o 0 = $f
then
  echo "Your \"$FGREP\" program seems to be incapable of returning a proper"
  echo "exitvalue depending on the success of the search.  This script can"
  echo "not work without it."
  exit 2
fi

nocore=yes
test -f core && nocore=no

cat >grepfor <<HERE
$FGREP -e "\$1" _autotst.rrr >$DEVNULL && echo "\$2" >>$ACONF
HERE
chmod 0755 grepfor

cat >$ACONF <<HERE
/* This file was automagically generated by autoconf */

HERE

echo 'Checking for POSIX and ANSI system include files'
test -f $USRINC/unistd.h || echo "#define UNISTD_H_MISSING" >>$ACONF
test -f $USRINC/stddef.h || echo "#define STDDEF_H_MISSING" >>$ACONF
test -f $USRINC/stdlib.h || echo "#define STDLIB_H_MISSING" >>$ACONF
if test ! -f $USRINC/dirent.h
then echo "#define DIRENT_H_MISSING" >>$ACONF
  if test ! -f $USRINC/ndir.h
  then echo "#define NDIR_H_MISSING" >>$ACONF
     if test ! -f $USRINC/sys/ndir.h
     then echo "#define SYS_NDIR_H_MISSING" >>$ACONF
	if test ! -f $USRINC/sys/dir.h
	then echo "#define SYS_DIR_H_MISSING" >>$ACONF
	   test -f $USRINC/sys/dirent.h ||
	    echo "#define SYS_DIRENT_H_MISSING" >>$ACONF
	fi
     fi
  fi
fi
test -f $USRINC/sys/wait.h || echo "#define SYS_WAIT_H_MISSING" >>$ACONF
test -f $USRINC/sys/utsname.h || echo "#define SYS_UTSNAME_H_MISSING" >>$ACONF
test -f $USRINC/string.h || echo "#define STRING_H_MISSING" >>$ACONF
test -f $USRINC/sysexits.h || echo "#define SYSEXITS_H_MISSING" >>$ACONF

echo >_locktst.h
test -f $USRINC/sys/locking.h ||
 echo "#define SYS_LOCKING_H_MISSING" >>_locktst.h
test -f $USRINC/sys/file.h || echo "#define SYS_FILE_H_MISSING" >>_locktst.h
$FGREP setsid $USRINC/sys/unistd.h >$DEVNULL 2>&1 ||
 echo "#define setsid()" >>_locktst.h

$RM _autotst.$O _autotst

cat >_autotst.c <<HERE
#include "$ACONF"
#include <sys/types.h>
#ifndef UNISTD_H_MISSING
#include <unistd.h>
#endif
#include <fcntl.h>
#ifndef SYS_FILE_H_MISSING
#include <sys/file.h>
#endif
main(){
#ifdef F_SETLKW
 fcntl(0,F_SETLKW,0);
#endif
#ifdef F_LOCK
  lockf(0,F_LOCK,0L);
#endif
#ifdef LOCK_EX
  flock(0,LOCK_EX);
#endif
 return 0;}
HERE

echo 'Initiating fcntl()/kernel-locking-support tests'
echo   '********************************************************************'
echo   '* If your system has mounted a REMOTE filesystem (like per NFS),   *'
echo   '* then it would be advisable to compile these sources from within  *'
echo   '* that filesystem, otherwise the locking tests might produce false *'
echo   '* results (locking capability is file-system dependent)		   *'
echo   '********************************************************************'
if $MAKE _autotst.$O >_autotst.rrr 2>&1
then
:
else
  echo 2>&1 "Whoeaaa!  There's something fishy going on here."
  echo 2>&1 "You have a look and see if you detect anything uncanny:"
  echo 2>&1 "-------------------------------------------------------"
  cat 2>&1 _autotst.rrr
  echo 2>&1 "-------------------------------------------------------"
  echo 2>&1 "I suggest you take a look at the definition of CFLAGS* and CC"
  echo 2>&1 "in the Makefile before you try make again."
  kill -15 $$
fi
$MAKE _autotst >_autotst.rrr 2>&1
$RM _autotst.$O _autotst

$FGREP fcntl _autotst.rrr >$DEVNULL && echo "#undef F_SETLKW" >>_locktst.h
$FGREP lockf _autotst.rrr >$DEVNULL && echo "#undef F_LOCK" >>_locktst.h
$FGREP flock _autotst.rrr >$DEVNULL && cat >>_locktst.h <<HERE
#ifdef LOCK_EX
#undef LOCK_EX
#endif
#ifndef SYS_FILE_H_MISSING
#define SYS_FILE_H_MISSING
#endif
HERE

cat >_autotst.c <<HERE
#include "$ACONF"
#include "../config.h"
#include <sys/types.h>
#ifndef UNISTD_H_MISSING
#include <unistd.h>		/* getppid() */
#endif
#include <stdio.h>
#include <time.h>
#include <fcntl.h>
#include <signal.h>		/* SIGKILL */
#ifndef tell
#define tell(fd)	lseek(fd,0L,SEEK_CUR)
#endif
#define EX_OK	0
#include "_locktst.h"
#ifndef SYS_FILE_H_MISSING
#include <sys/file.h>
#endif
#ifndef SEEK_SET
#define SEEK_SET	0
#define SEEK_CUR	1
#define SEEK_END	2
#endif

#define MIN_locks	128	  /* minimum of consecutive successful locks */
#define SLEEP_loop	64		      /* iterations in the busy loop */
#define SLEEP_delay	0		  /* sleep() time per busy iteration */
#define TIME_OUT_SEC	16			 /* initial timeout per lock */
#define NR_of_forks	8			 /* concurrent test-programs */
#define NR_of_lockfiles 2		  /* lockfiles used in testing (<=4) */
#define GROW		3			    /* when timing got worse */
#define DECAY		7/8			   /* when timing got better */
#define GOBBLE		256			 /* for the SunOS crash test */

#define SHIFT_childno	3
#define MASK_fileno	((1<<SHIFT_childno)-1)
#define MASK_childno	(~MASK_fileno)

#ifdef NO_fcntl_LOCK
#undef F_SETLKW
#endif
#ifdef NO_lockf_LOCK
#undef F_LOCK
#endif
#ifdef NO_flock_LOCK
#undef LOCK_EX
#endif

#define FIRST_lock	0x04		/* testing is in order of importance */
#define MSK_fcntl	0x04	       /* don't change this order unless you */
#define MSK_lockf	0x02	       /* change locking.c as well, fdlock() */
#define MSK_flock	0x01

int dolock,child[NR_of_forks],timeout;

void stimeout()
{ timeout=1;killchildren();
}

static unsigned long seed;

unsigned psrand()
{ return(unsigned)(seed*=69069L)>>8;
}

main()
{ int goodlock,testlock,i,pip[2];unsigned otimet,dtimet;
  static char filename[]="_locktst.l0";
  close(0);goodlock=0;testlock=FIRST_lock;
  if(fork())				 /* try to ditch the controlling tty */
     return EX_OK;	/* mainly to prevent rather messy kernel-diagnostics */
  setsid();				       /* from appearing on your tty */
  do
   { otimet=time((char*)0);signal(SIGTERM,SIG_DFL);dolock=goodlock|testlock;
     if(fork())	      /* discard the old body, let "init" adopt our children */
      { close(1);close(2);i=NR_of_lockfiles;
	do			       /* prime the lock, see if it vanishes */
	 { filename[sizeof filename-2]='0'+--i;
	   lseek(goodlock=open(filename,O_WRONLY),0L,SEEK_END);
	   fdlock(goodlock);
	 }
	while(i);
	for(;;)					/* synchronising "busy"-wait */
	   sleep(TIME_OUT_SEC);		   /* until the games can be started */
      }
     sleep(1);pipe(pip);i=NR_of_forks;*child=0;
     fprintf(stderr,"\nStarting test %x\n",dolock);
     while((child[--i]=fork())&&i);		       /* divide and conquer */
     if(!*child)
      { unsigned char lockflag;int fd,childno=i<<SHIFT_childno;
	close(pip[0]);close(1);seed=time((char*)0)+getpid()|1;
	for(;;)						   /* and lock away! */
	 { filename[sizeof filename-2]='0'+(i=psrand()%NR_of_lockfiles);
	   lockflag=childno|i<<1|1;
	   lseek(fd=open(filename,O_WRONLY),0L,SEEK_END);
	   if(sfdlock(fd))
	      lockflag&=~1,fprintf(stderr,"XX%02x",lockflag);
	   write(pip[1],&lockflag,1);
	   fprintf(stderr,"%2x%02x",i,childno>>SHIFT_childno);
	   lseek(fd,0L,SEEK_END);write(fd,&lockflag,1);
	   for(i=SLEEP_loop;i;i--,time((char*)0),sleep(SLEEP_delay));
	   lockflag&=~1;write(pip[1],&lockflag,1);
	   if(fdunlock()||close(fd))
	    { write(pip[1],&lockflag,1);fprintf(stderr,"XX%02x",lockflag);
	      return 1;
	    }
	 }
      }
    {unsigned char lckdfil[NR_of_lockfiles],curflag;int j,countlocks=MIN_locks;
     for(j=NR_of_lockfiles;lckdfil[--j]=0,j;); /* give all children a chance */
     close(pip[1]);timeout=0;sleep(1);kill(getppid(),SIGKILL);
     signal(SIGALRM,(void(*)())stimeout);
     dtimet=(((unsigned)time((char*)0)-otimet)*GROW)+TIME_OUT_SEC;
     do
      { unlink("_locktst.alive");alarm(dtimet+2);		 /* watchdog */
	dtimet=(otimet=time((char*)0)-otimet)>dtimet?
	 otimet*GROW:otimet+(dtimet-otimet)*DECAY+1;	   /* load dependent */
	otimet=time((char*)0);
      }
     while(1==read(pip[0],&curflag,1)&&(j=lckdfil[i=(curflag&MASK_fileno)>>1],
      !timeout)&&((j^(lckdfil[i]=curflag))==1||!(j&1)&&curflag&1)&&
      --countlocks);
     alarm(0);killchildren();close(pip[0]);
#ifdef FAIR_LOCK_CHECK
     j=NR_of_lockfiles;
     do
	if(!lckdfil[--j])			    /* was the locking fair? */
	   countlocks+=MIN_locks;				     /* nope */
     while(j);
#endif
     fprintf(stdout,
      "/*locktype: %x, countlocks: %x, timeout %x, watchdog %x*/\n",dolock,
      countlocks,timeout,dtimet);fflush(stdout);
     if(!countlocks)			    /* Hurray!	Locking was flawless */
	goodlock=dolock;			  /* make a mark on our colt */
    }
   }
  while(testlock>>=1);
  if(!(goodlock&MSK_fcntl))			      /* report our findings */
     puts("#define NOfcntl_lock");
  if(goodlock&MSK_lockf)
     puts("#define USElockf");
  if(goodlock&MSK_flock)
   { puts("#define USEflock");
#ifdef SYS_FILE_H_MISSING
     puts("#define SYS_FILE_H_MISSING");
#endif
   }
  puts("Kernel-locking tests completed.");
  return EX_OK;
}

killchildren()
{ int i;
  i=NR_of_forks;
  do
     if(child[--i]>0)
	kill(child[i],SIGTERM),child[i]=0;
  while(i);
}

sfdlock(fd)
{ int i;unsigned gobble[GOBBLE>>2];
  for(i=GOBBLE>>2;i;gobble[--i]=~(unsigned)0);		 /* SunOS crash test */
  return fdlock(fd);
}

static oldfdlock;
#ifdef F_SETLKW
static struct flock flck;		/* why can't it be a local variable? */
#endif
#ifdef F_LOCK
static long oldlockoffset;
#endif

fdlock(fd)
{ int i;unsigned gobble[GOBBLE>>2];
  for(i=GOBBLE>>2;i;gobble[--i]=~(unsigned)0);		 /* SunOS crash test */
  oldfdlock=fd;fd=0;
  if(MSK_fcntl&dolock)
#ifdef F_SETLKW
   { flck.l_type=F_WRLCK;flck.l_whence=SEEK_SET;flck.l_len=0;
     flck.l_start=tell(oldfdlock);fd|=fcntl(oldfdlock,F_SETLKW,&flck);
   }
#else
     fd=1;
#endif
  if(MSK_lockf&dolock)
#ifdef F_LOCK
     oldlockoffset=tell(oldfdlock),fd|=lockf(oldfdlock,F_LOCK,0L);
#else
     fd=1;
#endif
  if(MSK_flock&dolock)
#ifdef LOCK_EX
     fd|=flock(oldfdlock,LOCK_EX);
#else
     fd=1;
#endif
  return fd;
}

fdunlock()
{ int i;unsigned gobble[GOBBLE];
  for(i=GOBBLE;i;gobble[--i]=~(unsigned)0);		 /* SunOS crash test */
  if(MSK_flock&dolock)
#ifdef LOCK_EX
     i|=flock(oldfdlock,LOCK_UN);
#else
     i=1;
#endif
  if(MSK_lockf&dolock)
#ifdef F_LOCK
   { lseek(oldfdlock,oldlockoffset,SEEK_SET);i|=lockf(oldfdlock,F_LOCK,2L);
     i|=lockf(oldfdlock,F_ULOCK,0L);
   }
#else
     i=1;
#endif
  if(MSK_fcntl&dolock)
#ifdef F_SETLKW
   { flck.l_len=2;i|=fcntl(oldfdlock,F_SETLK,&flck);flck.l_type=F_UNLCK;
     flck.l_len=0;i|=fcntl(oldfdlock,F_SETLK,&flck);
   }
#else
     i=1;
#endif
  if(!i)
     for(i=GOBBLE;i&&gobble[--i]==~(unsigned)0;);
  return i;
}
HERE

if $MAKE _autotst >_autotst.rrr 2>&1
then
:
else
  echo 2>&1 "Whoeaaa!  There's something fishy going on here."
  echo 2>&1 "You have a look and see if you detect anything uncanny:"
  echo 2>&1 "-------------------------------------------------------"
  cat 2>&1 _autotst.rrr
  echo 2>&1 "-------------------------------------------------------"
  echo 2>&1 "I suggest you take a look at the definition of LDFLAGS*"
  echo 2>&1 "in the Makefile before you try make again."
  kill -15 $$
fi

$MV _locktst _locktst.$$ 2>$DEVNULL
$RM _autotst.$O _autotst.rrr locktst* 2>$DEVNULL
$MV _autotst _locktst
for a in 0 1 2 3
do echo dummy_file >_locktst.l$a
done
_locktst >_locktst.rrr 2>lock.log	# this will finish in the background
echo 'Proceeding with kernel-locking-support tests in the background'

test -f $USRINC/sys/socket.h -a -f $USRINC/netdb.h -a -f $USRINC/netinet/in.h||
 echo "#define NO_COMSAT" >>$ACONF

cat >_autotst.c <<HERE
#include "$ACONF"
#ifndef UNISTD_H_MISSING
#include <unistd.h>		/* execvp() */
#endif
main()
{ char*const*p;char*q="";static struct{const int a;int b;}c[2];
  --(c+1)->b;				 /* AIX 3.1.5 machines can't do this */
  p= &q;
  execvp(q,p);	  /* IRIX 4.0.1 system-include files are wrong on this point */
}
HERE

echo 'Testing for const'
if $MAKE _autotst.$O 2>&1 | $FGREP -v /include/ >_autotst.rrr &&
 test -f _autotst.$O
then
  grepfor const '#define const'
else
  echo '#define const' >>$ACONF
fi
$RM _autotst.$O

cat >_autotst.c <<HERE
main(){volatile int i;return(i=0);}
HERE

echo 'Testing for volatile'
if $MAKE _autotst.$O >$DEVNULL 2>&1 && test -f _autotst.$O
then
:
else
 echo '#define volatile' >>$ACONF
fi
$RM _autotst.$O

if $FGREP const $ACONF >$DEVNULL
then
  echo '#define P(args) ()' >>$ACONF
else
  cat >_autotst.c <<HERE
main(const argc,const char*const argv[]){return argc;}
HERE

  echo 'Testing for prototypes'
  if $MAKE _autotst.$O >$DEVNULL 2>&1 && test -f _autotst.$O
  then
  :
  else
     echo '#define P(args) ()' >>$ACONF
  fi
  $RM _autotst.$O
fi

cat >_autotst.c <<HERE
#include "includes.h"
#ifndef NO_COMSAT
#include "network.h"
#endif
void*vvoid;
main(){int i;char*p="t";
 {size_t vsize_t;i=vsize_t=1;}
 {pid_t vpid_t;i=vpid_t=1;}
 {time_t vtime_t;i=vtime_t=1;}
 {mode_t vmode_t;i=vmode_t=1;}
 {uid_t vuid_t;i=vuid_t=1;}
 {gid_t vgid_t;i=vgid_t=1;}
#ifndef NO_COMSAT
 {struct hostent host;i=!(host.h_addr_list=0);}
#endif
 vvoid=p;
 return !vvoid;}
HERE

echo 'Testing for void*,size_t,pid_t,time_t,mode_t,uid_t,gid_t'
$MAKE _autotst.$O 2>&1 | $FGREP -v /include/  >_autotst.rrr
$RM _autotst.$O

grepfor void '#define void char'
grepfor size_t 'typedef unsigned size_t;'
grepfor pid_t 'typedef int pid_t;'
grepfor time_t 'typedef long time_t;'
grepfor mode_t 'typedef int mode_t;'
grepfor uid_t 'typedef int uid_t;'
grepfor gid_t 'typedef int gid_t;'
grepfor h_addr_list '#define h_addr_list h_addr' ||
 grepfor struct '#define h_addr_list h_addr'

cat >_autotst.c <<HERE
#include "includes.h"
main(){int i;i=1;
 i+=WIFEXITED(i);
 i+=WIFSTOPPED(i);
 i+=WEXITSTATUS(i);
 return i;}
HERE

echo 'Testing for WIFEXITED(), WIFSTOPPED() & WEXITSTATUS()'
if $MAKE _autotst.$O 2>&1 | $FGREP -v /include/	 >_autotst.rrr
then
   grepfor struct '#define WMACROS_NON_POSIX' ||
    grepfor union '#define WMACROS_NON_POSIX'
else
   echo '#define WMACROS_NON_POSIX' >>$ACONF
fi
$RM _autotst.$O

cat >_autotst.c <<HERE
#include "includes.h"
#ifndef NO_COMSAT
#include "network.h"
#endif
main(){char a[2];
 endpwent();endgrent();memmove(a,"0",1);bcopy("0",a,1);strcspn(a,"0");
 strtol("0",(char**)0,10);strchr("0",'0');strpbrk(a,"0");rename(a,"0");
 opendir("0");initgroups("0",0);
#ifndef NOuname
 {struct utsname b;uname(&b);}
#endif
#ifndef NO_COMSAT
 gethostbyname("0");endhostent();endservent();endprotoent();
#endif
 return 0;}
HERE

echo 'Testing for memmove, strchr, strpbrk, strcspn, strtol & opendir'
$MAKE _autotst.$O >$DEVNULL 2>&1
$MAKE _autotst 2>&1 | $FGREP -v /include/  >_autotst.rrr
$RM _autotst _autotst.$O

grepfor strcspn '#define NOstrcspn'
grepfor strpbrk '#define NOstrpbrk'
grepfor opendir "
#define NOopendir	/* the readdir library does not seem to be available
			   this will slightly affect the way a filenumber is
			   selected in MH-folders by procmail */
"
grepfor rename '#define NOrename'
grepfor strchr '#define strchr(s,c) index(s,c)'
grepfor uname "\
#define NOuname		 \
/* the include files define it, the libraries don't */"
grepfor initgroups '#define initgroups(n,g)'
grepfor endpwent '#define endpwent()'
grepfor endgrent '#define endgrent()'
if grepfor gethostbyname '#define NO_COMSAT'
then
:
else
  grepfor endhostent '#define endhostent()'
  grepfor endservent '#define endservent()'
  grepfor endprotoent '#define endprotoent()'
fi
grepfor strtol '#define NOstrtol'
grepfor memmove '#define NOmemmove' &&
if $FGREP -e bcopy _autotst.rrr >$DEVNULL
then
 echo '#define NObcopy' >>$ACONF

 echo 'Testing for brain damage'
 cat >_autotst.c <<HERE
#include "includes.h"
struct tests{int a,b;};
main(){
 return offsetof(struct tests,b);}
HERE
 if $MAKE _autotst.$O >$DEVNULL 2>&1
 then
    :
 else
    echo 'Yep, it is'			# ISC chokes on its own offsetof()
    echo '#define oBRAIN_DAMAGE' >>$ACONF
 fi
 $RM _autotst.$O

else

 cat >_autotst.c <<HERE
#include "includes.h"
#define M256	256
#define F33	33
main(){int j=0,i=M256-1;static char a[M256];
  do a[i]=i;while(i--);
  bcopy(a+F33,a,M256-F33);bcopy(a,a+F33,M256-F33);i=F33-1;
  do j|=a[i]!=(char)(i+F33);while(i--);i=M256-1;
  do j|=a[i]!=(char)i;while(--i!=F33-1);return!j;}
HERE

 echo 'Testing for bcopy handling overlaps'
 $MAKE _autotst >$DEVNULL 2>&1

 if _autotst
 then
   echo 'Sorry, incompetent bcopy'
   echo '#define NObcopy' >>$ACONF
 fi
 $RM _autotst
fi

$FGREP -e LD_ /bin/ld >/dev/null 2>&1 && echo "#define LD_ENV_FIX" >>$ACONF
test -f /bin/test && echo "#define GOT_bin_test" >>$ACONF

cat >_autotst.c <<HERE
#include "includes.h"
#ifndef NO_COMSAT
#include "network.h"					 /* also for ntohs() */
#endif
main(argc)
{ unsigned long s=(size_t)~0;int i;
  for(i=1;s>>=1;i++);
  if(argc==1)
   {
#ifndef NO_COMSAT
    {const struct protoent*p;
     if(p=getprotobyname(COMSATprotocol))
      { const struct servent*serv;
	printf("#define UDP_protocolno %d\n",p->p_proto);
	if(serv=getservbyname(COMSATservice,COMSATprotocol))
	   printf("#define BIFF_serviceport \"%d\"\n",ntohs(serv->s_port));
#ifdef AF_INET
       {const struct hostent*host;
	if(!strcmp("localhost",COMSAThost)&&(host=gethostbyname(COMSAThost))&&
	 host->h_addr_list[0]&&host->h_addrtype==AF_INET&&host->h_length)
	 { int j=host->h_length;const unsigned char*ad=host->h_addr_list[0];
	   printf("#define IP_localhost {");
	   do printf("%d,",*ad++);
	   while(--j);
	   puts("}");
	 }
       }
#endif /* AF_INET */
      }
     else
	puts("#define NO_COMSAT");
    }
#endif /* NO_COMSAT */
     if(i<=16)
      { puts("#define SMALLHEAP");return 1;
      }
#ifdef _GUID_T			/* ISC cc hack */
     ;{ struct pass*p;
	if(sizeof(int)>sizeof(uid_t)&&(p=getpwnam("root"))&&(*p->pw_dir!='/'||
	 (*p->pw_shell&&!(p->pw_shell)[1]))
	   puts("#define _GUID_T\ntypedef int uid_t;\ntypedef int gid_t;");
      }
#endif
   }
#ifdef SYSTEM_MBOX
  if(argc==2)
     printf("#define SYSTEM_MAILBOX %s\n",SYSTEM_MBOX),return 1;
#endif
#ifdef DEFsendmail
  if(argc==3)
     printf("#define SENDMAIL %s\n",DEFsendmail),return 1;
#endif
  return 0;
}
HERE

echo 'Determining the most applicable block size'

$MAKE _autotst >$DEVNULL 2>&1
_autotst >>$ACONF

found=no
for a in /usr/spool/mail /usr/mail /var/spool/mail /var/mail
do
  test -d $a -a $found != yes &&
   echo '#define SYSTEM_MAILBOX "'$a'/$LOGNAME"' >>$ACONF && found=yes
done
if test $found != yes && _autotst 2 >>$ACONF
then
 echo '#define SYSTEM_MAILBOX "$HOME/.mail"' >>$ACONF
 echo Could not find the system-mailbox directory, supplied substitute
fi

cat >lookfor <<HERE
for a in /usr/lib /lib /usr/etc /etc /usr/bin /bin /usr/local/bin /usr/lbin \
 /usr/local/lib /usr/local /usr/.lib
do
 if test -f "\$a/\$1"
 then
    echo "#define SENDMAIL \"\$a/\$1\"" >>$ACONF
    exit 0
 fi
done
exit 1
HERE
chmod 0755 lookfor

if lookfor sendmail || lookfor smail
then
:
elif _autotst 2 3 >>$ACONF
then
 echo 'Could not find any mailer.  It should be a mailer accepting at least'
 echo 'one plain destination address as its only argument (any sendmail'
 echo 'compatible mailer will do), and the mail-to-be-sent on stdin.'
 echo 'What is your mailer called?  (You can override this in config.h)'
 read a
 echo "#define SENDMAIL \"$a\"" >>$ACONF
fi

cat /usr/lib/sendmail.cf /etc/sendmail.cf 2>$DEVNULL |
 grep 'Mlocal.*procmail' >$DEVNULL ||
 echo '#define CF_no_procmail_yet' >>$ACONF

tailpid=""

while $FGREP -e "Kernel-locking tests completed." _locktst.rrr >$DEVNULL; \
 test 0 != $?
do
  if test -z "$tailpid"
  then
     echo "Waiting for kernel-locking tests to finish..."
     exec 9>&2 2>$DEVNULL
     tail -f lock.log &
     tailpid=$!
     exec 2>&9 9>&-
  fi
# if test ! -f _locktst.alive
# then
#    echo >_locktst.alive
#    echo "Waiting for kernel-locking tests to finish..."
# fi
  sleep 4
done
exec 9>&2 2>$DEVNULL
test ! -z "$tailpid" && kill $tailpid && echo && echo
exec 2>&9 9>&-
echo "Collecting results from kernel-locking tests"
sed -e '/^Kernel-locking tests completed./,$ d' <_locktst.rrr >>$ACONF
if test -f core -a $nocore = yes
then
  echo "Removing core file (probably from the locking tests)"
  $RM core
fi

$RM _autotst* _locktst* lookfor grepfor 2>$DEVNULL

echo =============================autoconf.h===================================
cat $ACONF
echo ==========================================================================
